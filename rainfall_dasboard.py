# -*- coding: utf-8 -*-
"""rainfall_dasboard

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RexXpaBF2vdlXKBGVUTuqcg2BNBFoOzc

TASK 2: Data Cleaning & Preprocessing for the Rainfall dataset.
"""

import pandas as pd
import numpy as np

# Load data
df = pd.read_csv("rainfall in india 1901-2015 (1).csv")

print("üìÇ First 5 rows:")
display(df.head())

print("\nüìè Dataset Shape:", df.shape)

print("\nüîç Column Info:")
df.info()

# Check missing values
print("\n‚ùì Missing Values:")
print(df.isnull().sum())

# Option 1: Drop rows with null values
df = df.dropna()

# Option 2 (Alternative): Fill missing using mean
# df = df.fillna(df.mean())

print("\nüßπ Duplicates removed:", df.duplicated().sum())
df = df.drop_duplicates()

df['YEAR'] = df['YEAR'].astype(int)   # Year should be integer
df = df.apply(pd.to_numeric, errors='ignore')  # Convert numeric columns properly

df.columns = df.columns.str.replace(' ', '_').str.upper()

print("\n‚úÖ Cleaned Dataset Info:")
df.info()

print("\nüìÇ Preview Cleaned Data:")
display(df.head())

"""First, we loaded the dataset and inspected its structure.

We checked and handled missing values, removed duplicates, and corrected datatypes.

Then we standardized column names for easier processing.

This ensures clean and reliable data for further EDA and machine-learning tasks.

TASK 3: Exploratory Data Analysis (EDA) for the Rainfall dataset.

Summary statistics

Rainfall distribution plot

Seasonal rainfall comparison

Annual rainfall trend quick view
"""

# Summary of dataset
print("üìà Summary Statistics")
display(df.describe())

# Unique subdivisions count
print("\nüåç Number of Indian Regions/Subdivisions:", df['SUBDIVISION'].nunique())

# Dataset period
print(f"\nüìÖ Data Range: {df['YEAR'].min()} - {df['YEAR'].max()}")

import matplotlib.pyplot as plt

plt.figure(figsize=(8,5))
plt.hist(df["ANNUAL"], bins=20, alpha=0.7)
plt.title("Distribution of Annual Rainfall in India (1901‚Äì2015)")
plt.xlabel("Annual Rainfall (mm)")
plt.ylabel("Frequency")
plt.grid(True)
plt.show()

import seaborn as sns

season_cols = ['JAN-FEB','MAR-MAY','JUN-SEP','OCT-DEC','ANNUAL']

plt.figure(figsize=(8,5))
sns.barplot(x=season_cols, y=df[season_cols].mean())
plt.title("Average Seasonal Rainfall in India (1901‚Äì2015)")
plt.ylabel("Average Rainfall (mm)")
plt.xlabel("Season")
plt.grid(True)
plt.show()

df_sorted = df.sort_values("YEAR")

plt.figure(figsize=(10,5))
plt.plot(df_sorted["YEAR"], df_sorted["ANNUAL"], color="purple", alpha=0.7)
plt.title("Annual Rainfall Trend (1901‚Äì2015)")
plt.xlabel("Year")
plt.ylabel("Annual Rainfall (mm)")
plt.grid(True)
plt.show()

top_regions = df.groupby("SUBDIVISION")["ANNUAL"].mean().sort_values(ascending=False).head(10)

plt.figure(figsize=(8,6))
sns.barplot(y=top_regions.index, x=top_regions.values)
plt.title("Top 10 Rainiest Regions in India (Avg Annual Rainfall)")
plt.xlabel("Average Annual Rainfall (mm)")
plt.ylabel("Subdivision")
plt.show()

"""During EDA, we examined rainfall distribution, seasonal averages, and long-term rainfall trends.

We visualized annual rainfall from 1901‚Äì2015 and compared seasonal contributions.

This helps understand monsoon dependency, drought years, and climate fluctuations in India.

TASK 4: Correlation Heatmap for your Rainfall in India (1901‚Äì2015) dataset.
"""

import seaborn as sns
import matplotlib.pyplot as plt

# Select only numerical seasonal & annual columns
season_cols = ['JAN-FEB','MAR-MAY','JUN-SEP','OCT-DEC','ANNUAL']
corr = df[season_cols].corr()

plt.figure(figsize=(8,6))
sns.heatmap(corr, annot=True, cmap="coolwarm", fmt=".2f", linewidths=.5)
plt.title("Correlation Heatmap ‚Äî Seasonal vs Annual Rainfall")
plt.show()

"""We plotted a correlation heatmap for seasonal rainfall values.

It shows the strength of relationship between seasonal rainfall and annual rainfall.

The monsoon period (June-September) shows the highest correlation with annual rainfall, indicating India‚Äôs rainfall pattern is primarily monsoon-driven.

TASK 5: Time-Series Trend (Smoothed)

We will visualize long-term rainfall trend using moving average smoothing to understand climate pattern change over time.
"""

import matplotlib.pyplot as plt

# Sort by year to maintain time order
df = df.sort_values("YEAR")

# Create Moving Average Columns (5-year & 10-year)
df["MA_5"] = df["ANNUAL"].rolling(window=5).mean()
df["MA_10"] = df["ANNUAL"].rolling(window=10).mean()

# Plot
plt.figure(figsize=(10,5))
plt.plot(df["YEAR"], df["ANNUAL"], color="gray", alpha=0.4, label="Actual Annual Rainfall")
plt.plot(df["YEAR"], df["MA_5"], color="red", linewidth=2, label="5-Year Moving Average")
plt.plot(df["YEAR"], df["MA_10"], color="blue", linewidth=2, label="10-Year Moving Average")

plt.title("Smoothed Annual Rainfall Trend in India (1901‚Äì2015)")
plt.xlabel("Year")
plt.ylabel("Rainfall (mm)")
plt.grid(True)
plt.legend()
plt.show()

"""What this plot shows

Grey = actual rainfall (year-to-year fluctuation)

Red = 5-year trend (short-term climate trend)

Blue = 10-year trend (long-term climate trend)

üìâ If the line slopes downward ‚Üí long-term decrease in rainfall

üìà If rising ‚Üí long-term increase

‚ÜïÔ∏è If flat ‚Üí stable pattern

We smoothed annual rainfall series using 5-year and 10-year moving averages.
This removes short-term noise and highlights long-term climate trends.
The trend helps observe drought cycles, monsoon variation, and climate change signals.

TASK 5: Seasonal vs Annual Rainfall Comparison

This task helps show how each season contributes to the annual rainfall.
We will create:

Scatter plots with trendline (Season vs Annual)

Multi-line graph for seasonal rainfall across years
"""

import seaborn as sns
import matplotlib.pyplot as plt

season_cols = ['JAN-FEB','MAR-MAY','JUN-SEP','OCT-DEC']

for season in season_cols:
    plt.figure(figsize=(7,5))
    sns.regplot(x=df[season], y=df["ANNUAL"], scatter_kws={"alpha":0.5}, line_kws={'color':'red'})
    plt.title(f"{season} vs Annual Rainfall")
    plt.xlabel(f"{season} Rainfall (mm)")
    plt.ylabel("Annual Rainfall (mm)")
    plt.grid(True)
    plt.show()

"""Insight you will see

Jun-Sep (Monsoon) ‚âà strongest effect on annual rainfall (steep trend line)

Winter (Jan-Feb) lowest impact
"""

df_sorted = df.sort_values("YEAR")

plt.figure(figsize=(12,6))

plt.plot(df_sorted["YEAR"], df_sorted["ANNUAL"], label="Annual", linewidth=2, color="black")

for season in season_cols:
    plt.plot(df_sorted["YEAR"], df_sorted[season], linewidth=1.6, alpha=0.8, label=season)

plt.title("Seasonal vs Annual Rainfall Trend (1901‚Äì2015)")
plt.xlabel("Year")
plt.ylabel("Rainfall (mm)")
plt.grid(True)
plt.legend()
plt.show()

"""We compared seasonal rainfall with annual rainfall using scatter plots and trendlines.
The monsoon season (June-September) shows a strong positive relationship with annual rainfall, confirming that India's rainfall is monsoon-driven.
A seasonal multi-line plot also shows long-term seasonal variation across decades.

TASK 6: Linear Regression to Predict Annual Rainfall
"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np
import matplotlib.pyplot as plt

# Features (seasonal rainfall)
X = df[['JAN-FEB', 'MAR-MAY', 'JUN-SEP', 'OCT-DEC']]

# Target (annual rainfall)
y = df['ANNUAL']

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Model
model = LinearRegression()
model.fit(X_train, y_train)

# Predictions
y_pred = model.predict(X_test)

# Evaluation Metrics
mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
r2 = r2_score(y_test, y_pred)

print("üìä Linear Regression Model Evaluation")
print(f"MAE: {mae:.2f}")
print(f"RMSE: {rmse:.2f}")
print(f"R¬≤ Score: {r2:.4f}")

plt.figure(figsize=(7,5))
plt.scatter(y_test, y_pred, color="blue", alpha=0.6)
plt.plot([y.min(), y.max()], [y.min(), y.max()], 'r--') # reference line
plt.title("Actual vs Predicted Annual Rainfall")
plt.xlabel("Actual Annual Rainfall")
plt.ylabel("Predicted Annual Rainfall")
plt.grid(True)
plt.show()

coeff = pd.DataFrame({"Season": X.columns, "Coefficient": model.coef_})
print("\nSeason Importance in Prediction:")
display(coeff)

"""We used Linear Regression to predict annual rainfall using seasonal rainfall values.
The model was trained on 80% of data and tested on 20%.
We evaluated the model using MAE, RMSE, and R¬≤ score.
The monsoon (Jun‚ÄìSep) contributed the most to annual rainfall prediction, proving India's dependence on monsoon systems

TASK 7: Multi-Linear Regression
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_squared_error
import numpy as np
import matplotlib.pyplot as plt

# Step 1: Load the dataset
df = pd.read_csv("rainfall in india 1901-2015 (1).csv")

# Step 2: Display the first few rows and columns
print("Columns in the dataset:")
print(df.columns.tolist())
print("\nPreview of data:")
print(df.head())

# Step 3: Define your target variable (change this based on your dataset)
# For example: target_col = 'ANNUAL'
target_col = 'ANNUAL'  # üëà change this if your dataset has a different target column

# Step 4: Select numeric columns
numeric_cols = df.select_dtypes(include=np.number).columns.tolist()

# Drop target from feature set
X = df[numeric_cols].drop(columns=[target_col], errors='ignore')
y = df[target_col]

# Step 5: Handle missing values (if any)
X = X.fillna(X.mean())
y = y.fillna(y.mean())

# Step 6: Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Step 7: Train the model
model = LinearRegression()
model.fit(X_train, y_train)

# Step 8: Make predictions
y_pred = model.predict(X_test)

# Step 9: Evaluate the model
r2 = r2_score(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)

print("\nüìä Model Evaluation:")
print(f"R¬≤ Score: {r2:.4f}")
print(f"Mean Squared Error: {mse:.4f}")
print(f"Root Mean Squared Error: {rmse:.4f}")

# Step 10: Display coefficients
print("\n‚öôÔ∏è Model Coefficients:")
for feature, coef in zip(X.columns, model.coef_):
    print(f"{feature}: {coef:.4f}")
print(f"Intercept: {model.intercept_:.4f}")

# Step 11: Plot Actual vs Predicted values
plt.figure(figsize=(6, 6))
plt.scatter(y_test, y_pred, color='blue', alpha=0.6)
plt.xlabel("Actual Rainfall")
plt.ylabel("Predicted Rainfall")
plt.title("Actual vs Predicted Rainfall (Multiple Linear Regression)")
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], color='red', lw=2)
plt.show()

"""TASK 8: ARIMA Time-Series Forecasting

to predict future rainfall.
"""

import pandas as pd

# Sort by year
df = df.sort_values("YEAR")

# Set YEAR column as index (important for ARIMA)
ts = df.set_index("YEAR")["ANNUAL"]

# Display first values
ts.head()

import matplotlib.pyplot as plt

plt.figure(figsize=(10,5))
plt.plot(ts, label="Annual Rainfall")
plt.title("Annual Rainfall in India (1901‚Äì2015)")
plt.xlabel("Year")
plt.ylabel("Rainfall (mm)")
plt.grid(True)
plt.legend()
plt.show()

from statsmodels.tsa.arima.model import ARIMA

model = ARIMA(ts, order=(1,1,1))
model_fit = model.fit()
print(model_fit.summary())

# Forecast next 10 years
forecast = model_fit.forecast(steps=10)

print("\nüìà Rainfall Forecast for Next 10 Years:")
print(forecast)

plt.figure(figsize=(10,5))
plt.plot(ts, label="Actual Rainfall")
plt.plot(range(ts.index[-1]+1, ts.index[-1]+1+10), forecast, label="Forecast", color='red', marker='o')

plt.title("Rainfall Forecast (ARIMA Model)")
plt.xlabel("Year")
plt.ylabel("Rainfall (mm)")
plt.grid(True)
plt.legend()
plt.show()

"""We used ARIMA time-series model to forecast Indian rainfall.
We converted the annual rainfall column into a time-series indexed by year, trained an ARIMA(1,1,1) model, and predicted future values.
ARIMA captures trend and past patterns to produce forecast values, helping detect long-term rainfall shifts and climate change patterns.

TASK 9: K-Means Rainfall Pattern Clustering
"""

import pandas as pd
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import seaborn as sns

# Use seasonal & annual columns for clustering
features = ['Jan-Feb','Mar-May','Jun-Sep','Oct-Dec','ANNUAL']

# Ensure df is cleaned by dropping rows with NaNs in the relevant features
# This will align the number of rows and indices for subsequent steps
df = df.dropna(subset=features)

X = df[features]

# No need for X.dropna() here as df is already cleaned

# Determine optimal number of clusters using the elbow method
inertia = []
for n_clusters in range(1, 11):
    kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
    kmeans.fit(X)
    inertia.append(kmeans.inertia_)

plt.figure(figsize=(8, 4))
plt.plot(range(1, 11), inertia, marker='o')
plt.title('Elbow Method for Optimal Number of Clusters')
plt.xlabel('Number of Clusters')
plt.ylabel('Inertia')
plt.xticks(range(1, 11))
plt.grid(True)
plt.show()

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

from sklearn.cluster import KMeans

kmeans = KMeans(n_clusters=3, random_state=42)
df['Rainfall_Cluster'] = kmeans.fit_predict(X_scaled)
df['Rainfall_Cluster'].value_counts()

# Sort clusters by mean annual rainfall for meaningful label assignment
cluster_mean = df.groupby('Rainfall_Cluster')['ANNUAL'].mean().sort_values()

mapping = {cluster_mean.index[0]:"Low Rainfall",
           cluster_mean.index[1]:"Moderate Rainfall",
           cluster_mean.index[2]:"High Rainfall"}

df['Rainfall_Level'] = df['Rainfall_Cluster'].map(mapping)

df[['YEAR','ANNUAL','Rainfall_Level']].head()

import matplotlib.pyplot as plt

plt.figure(figsize=(8,6))
for level, color in zip(["Low Rainfall","Moderate Rainfall","High Rainfall"], ['red','orange','green']):
    subset = df[df['Rainfall_Level']==level]
    plt.scatter(subset['Jun-Sep'], subset['ANNUAL'], label=level, alpha=0.7)

plt.title("K-Means Rainfall Clusters (India)")
plt.xlabel("Monsoon Rainfall (Jun-Sep)")
plt.ylabel("Annual Rainfall")
plt.legend()
plt.grid(True)
plt.show()

"""We applied K-Means clustering on seasonal and annual rainfall data to group years into Low, Moderate, and High rainfall categories.
We first standardized the values, then clustered into 3 groups.
The scatter plot shows how monsoon rainfall strongly influences annual rainfall.
This helps detect drought years, normal years, and wet years.

TASK 10: Outlier / Drought / Flood Year Detection
"""

import numpy as np

# Select annual rainfall
annual = df["ANNUAL"]

# IQR
Q1 = annual.quantile(0.25)
Q3 = annual.quantile(0.75)
IQR = Q3 - Q1

lower_limit = Q1 - 1.5 * IQR
upper_limit = Q3 + 1.5 * IQR

# Detect outliers
drought_years = df[df["ANNUAL"] < lower_limit][["YEAR","ANNUAL"]]
flood_years   = df[df["ANNUAL"] > upper_limit][["YEAR","ANNUAL"]]

print("üåµ Drought Years (Low Rainfall):")
print(drought_years)

print("\nüåä Flood/Heavy Rainfall Years:")
print(flood_years)

from scipy import stats

df["Zscore"] = stats.zscore(df["ANNUAL"])

drought_z = df[df["Zscore"] < -2][["YEAR","ANNUAL"]]
flood_z   = df[df["Zscore"] > 2][["YEAR","ANNUAL"]]

print("\nüåµ Drought Years (Z-Score < -2):")
print(drought_z)

print("\nüåä Flood Years (Z-Score > 2):")
print(flood_z)

import matplotlib.pyplot as plt

plt.figure(figsize=(6,5))
plt.boxplot(df["ANNUAL"])
plt.title("Boxplot ‚Äî Annual Rainfall in India")
plt.ylabel("Rainfall (mm)")
plt.grid(True)
plt.show()

plt.figure(figsize=(12,5))
plt.plot(df["YEAR"], df["ANNUAL"], label="Annual Rainfall", color='blue')

plt.scatter(drought_years["YEAR"], drought_years["ANNUAL"], color='red', s=80, label="Drought Years")
plt.scatter(flood_years["YEAR"], flood_years["ANNUAL"], color='green', s=80, label="Flood Years")

plt.title("Rainfall Trend Highlighting Drought & Flood Years")
plt.xlabel("Year")
plt.ylabel("Annual Rainfall (mm)")
plt.legend()
plt.grid(True)
plt.show()

"""We detected unusual rainfall years using IQR and Z-score methods.
Years falling below the lower bound are classified as drought years, while those above the upper bound are flood years.
We visualized these years on a boxplot and time-series graph to study climate anomalies.

TASK 11: LSTM
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

# Step 1: Load the dataset
df = pd.read_csv("rainfall in india 1901-2015 (1).csv")

print("Columns in dataset:")
print(df.columns.tolist())
print("\nPreview:")
print(df.head())

# Step 2: Select the target column for rainfall
# ‚îÄ Change 'ANNUAL' to your actual rainfall column if different
target_col = 'ANNUAL'

# Step 2.5: Handle missing values in the target column
df.dropna(subset=[target_col], inplace=True)

# Step 3: Extract rainfall values
data = df[[target_col]].values

# Step 4: Scale the data between 0 and 1
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(data)

# Step 5: Create sequences for LSTM (using 10 previous years to predict the next)
def create_sequences(dataset, time_steps=10):
    X, y = [], []
    for i in range(len(dataset) - time_steps):
        X.append(dataset[i:i + time_steps])
        y.append(dataset[i + time_steps])
    return np.array(X), np.array(y)

time_steps = 10
X, y = create_sequences(scaled_data, time_steps)

# Step 6: Split data into training and testing sets
train_size = int(len(X) * 0.8)
X_train, X_test = X[:train_size], X[train_size:]
y_train, y_test = y[:train_size], y[train_size:]

# Step 7: Build the LSTM model
model = Sequential([
    LSTM(50, return_sequences=False, input_shape=(X_train.shape[1], 1)),
    Dense(1)
])

model.compile(optimizer='adam', loss='mean_squared_error')

# Step 8: Train the model
history = model.fit(X_train, y_train, epochs=50, batch_size=8, validation_data=(X_test, y_test), verbose=1)

# Step 9: Predictions
y_pred = model.predict(X_test)
y_pred_rescaled = scaler.inverse_transform(y_pred)
y_test_rescaled = scaler.inverse_transform(y_test)

# Step 10: Evaluate
rmse = np.sqrt(mean_squared_error(y_test_rescaled, y_pred_rescaled))
print(f"\n‚ÜóÔ∏è RMSE: {rmse:.4f}")

# Step 11: Plot actual vs predicted rainfall
plt.figure(figsize=(10, 6))
plt.plot(y_test_rescaled, label='Actual Rainfall', color='blue')
plt.plot(y_pred_rescaled, label='Predicted Rainfall', color='red')
plt.title("Rainfall Prediction using LSTM")
plt.xlabel("Year Index")
plt.ylabel("Rainfall")
plt.legend()
plt.show()